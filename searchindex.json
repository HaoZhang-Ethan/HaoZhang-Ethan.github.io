[{"section":"Blog","slug":"/blog/post-5/","title":"冠词","description":"this is meta description","date":"April 15, 2024","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"279\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo\\/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo\\/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"English","tags":"Reading, Writing, Grammar, Article","content":"冠词的基本含义 冠词是用来修饰名词的一类词，主要用于指出名词的泛指或特指状态。在中文中没有冠词，但在英文等许多其他语言中，冠词是非常重要的语法成分。英文中的冠词主要有两种类型：定冠词和不定冠词。\n不定冠词（an, a）：用于泛指某一类人或事物。表示“一个（任意一个）”，常用语系列词后的单数名词（可数名词作表语）前，表示某人、某物属于哪个类别，用于泛指某人、某物或指某一类人或某一类物中的任何一个。例如，\u0026ldquo;a book\u0026rdquo; 表示“一本书”，泛指任何一本书。\u0026ldquo;an\u0026rdquo; 用于元音音开头的单词前，如 \u0026ldquo;an apple\u0026rdquo;。 定冠词（the）：用于特指某个已知的人或事物。表示特指某一个或者某一些，而不是任何一个或者任何一些。例如，\u0026ldquo;the book\u0026rdquo; 表示“那本书”，指特定的一本书。 冠词的使用注意 某可数名词单数首次出现时，通常先用不定冠词。第二次在提到时就改用定冠词。 Boys often like dogs very much. The animals can listen to their masters.\n如果有关各方都知道指何人、何物，尽管是第一次出现，仍用定冠词。 Silicon does not occur in the free state in nature, and very few people have seen the pure substance. [\u0026ldquo;游离状态\u0026quot;是共识，不是Silicon的游离状态是共识，而是\u0026quot;游离状态\u0026quot;本身是]\n特指某一个或者某一些。\n专有名词前面的the表示独一无味的事物，如 太阳、江河、山脉、国家等专有名词和形容词最高级前面的the。\n冠词的实用价值 用 a 和 one 有时意思有差别: a 指是“一个”、“任何一个”。而one侧重数字，即“一个”，而不是“两个”、“三个”。[这里应该还是主要在文字表达上，如果是口语，可以加重音强调] The roof will collapse at a blow. (这个屋顶一打准垮)\nThe roof will collapse at one blow. (这个屋顶打一下准垮)\n用或者不用冠词，意义上有差别\n物质名词不用冠词；若用冠词，意思就不同或具体化\nglass (玻璃); a glass (一只玻璃杯); the glass (这只玻璃杯);\nrion (铁); an iron (一个熨斗); irons (镣铐);\n某些词组用或不用冠词，意思也有所不同\nexperience 经验；an experience 一种经历；\nman 人类；a man 一个男人；\nBrown 姓；The Browns 伯朗一家\nthe red and white flower 红白花（一种杂色花）；the red and the white flwoer 红花和白花（两种花）；\nfew books 没说少书（含有否定意味）；a few books 少数几本书（虽然少，但是含有肯定意味）\nlittle water 没多少水（含有否定意味）；a little water 少许水（肯定意味）\nthree of us 我们中间的三个人[用来指代“我们三个人”中的任何三个人，没有强调具体是哪三个人或这三个人是特定的一组。]； the three of us 我们三个人[特指已知的、特定的那三个人。]\nout of question 毫无疑问；out of the question 不可能（常用作表语）\nbe at table 在吃饭；be at the table 在桌旁\ntake place （事故）发生；take the place of 代替（某人或某物）\nstand in front of the car 站在车子前面（在车外）；stand in the frond of the car 站在车子前部（在车上）\n抽象名词前一般不用冠词；若用冠词，意思就具体化\nThey are all of age. 他们都已成年\nWe are all of an age. 我们都是同龄人\n形容词最高级前不用the，则表示\u0026quot;十分\u0026hellip;\u0026rdquo;;\nThis is a most interesting book. 这是一本十分有趣的书\nThis is the most interesting book I have ever read. 这是我读过最有趣的一本书\n利用“冠词后面一般要求有名词”来判断词类。\n用来判断名词 They went to the play.\nWhen matter changes to a substance different from whiat is was, the change is a chemical change.\n在冠词和它所说明的名词之间一般都有定语\nthe building material\nthe moving water\nthe 后面只有形容词而无名词，则the使形容词名词化，是指代表某些人或物\nthe poor 穷人\nthe unexpected 意料不到的事\n参考资料 [1] 英语阅读手册，叶永昌\n声明 内容大部分来自参考文献本身，我的理解会使用[XXX]标记，仅供参考。\n"},{"section":"Blog","slug":"/blog/post-2/","title":"分布式缓存集群下数据分配策略","description":"this is meta description","date":"December 13, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo/DSC_0149_hu145784f766633acf37e89ddf20f1aa62_6451165_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"279\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo\\/DSC_0149_hu145784f766633acf37e89ddf20f1aa62_6451165_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo/DSC_0149_hu145784f766633acf37e89ddf20f1aa62_6451165_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo\\/DSC_0149_hu145784f766633acf37e89ddf20f1aa62_6451165_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Distributed Cache, Alluxio","tags":"Distributed Cache, Alluxio, 分布式缓存","content":"Data Location Awareness: Optimize Performance and Lower Cost with Tiered Locality Ref\nAlluxio 可以将位于不同存储介质的数据汇总到统一的存储池。 具体地说，Alluxio 使用了一种称为 Tiered Locality 的技术，该技术可以感知到数据的存储位置，从而优化数据访问性能和降低成本。 本文将介绍 Alluxio 的 Tiered Locality 技术，以及如何使用它来优化数据访问性能和降低成本。\n1. Alluxio Tiered Locality Alluxio 作为分布式缓存可以被搭建在不同的数据中心，不同的机架，不同的节点上。而单一存储节点因为容量以及IO性能的限制，往往无法满足大数据处理的需求。因此，Alluxio 作为分布式缓存，可以将位于不同存储介质的数据汇总到统一的存储池。而使用统一的存储池可能会造成数据访问性能的下降，因为数据的访问性能取决于数据的存储位置。数据越接近或越本地化，应用程序访问数据的速度就越快。Tiered locality 允许用户配置数据放置位置策略考虑集群网络拓扑结构实现访问性能。\n"},{"section":"Blog","slug":"/blog/post-4/","title":"服务器运行环境隔离方法（容器化）","description":"this is meta description","date":"December 13, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"279\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo\\/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo\\/DSC_0183_hue7be2dde7d334fe5895e8389347561f1_7567568_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Operating System-level Virtualization","tags":"服务器管理, Docker, Portainer","content":"一些环境隔离方法 虚拟化： 使用虚拟化技术，如 VMware、VirtualBox 或 KVM，可以在物理服务器上创建多个虚拟服务器，每个虚拟服务器都有自己独立的操作系统和资源。这提供了强大的隔离，防止一个虚拟机的问题影响其他虚拟机。 容器化： 使用容器技术，如 Docker，可以将应用程序及其依赖项打包成一个独立的容器。每个容器运行在独立的环境中，与主机和其他容器隔离。这提供了更轻量级的隔离，同时提高了灵活性和可移植性。 操作系统级别的隔离： 使用操作系统级别的隔离技术，如 Linux 的容器（LXC）或 FreeBSD 的 jails。这些技术允许将进程和文件系统隔离开来，每个隔离的环境都有自己的文件系统和进程空间。 这里，综合考虑实验室设备情况以及管理实现难度，我们选择的容器化技术，通过Docker实现环境隔离，Docker是一种轻量级容器技术，通过将应用程序及其依赖项打包成独立的容器，提供了一致性和可移植性。Portainer是一个用于简化Docker容器管理的开源工具，提供直观的Web界面，使用户能够轻松查看、创建、启动和停止Docker容器。\n实验室容器化平台使用方式\rDocker 简介 Docker 是一种开源的容器化平台，用于轻松地构建、打包、运输和运行应用程序。Docker 提供了一种将应用程序和其所有依赖项打包成一个独立的、可移植的容器的方法，这个容器可以在任何支持 Docker 的环境中运行，而不受底层系统的影响。\nDocker overview\rPortainer 简介 Portainer 是一个开源的轻量级容器管理工具，主要用于简化 Docker 容器的管理。通过提供直观的图形用户界面，Portainer 能够让用户轻松地查看、创建、启动、停止和管理 Docker 容器以及相关资源。\nPortainer overview\r配置环境过程 Ubuntu 22.04 LTS (GNU/Linux 5.15.0-25-generic x86_64)\nDocker 安装 安装 Docker 在 Ubuntu 上可以通过官方的安装脚本或者通过 apt 包管理工具进行。以下是两种常见的方法：\n方法一：使用官方安装脚本 更新 apt 软件包索引：\nsudo apt update 安装必要的依赖：\nsudo apt install apt-transport-https ca-certificates curl software-properties-common 添加 Docker GPG 密钥：\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 设置稳定版 Docker 存储库：\necho \u0026#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 更新 apt 软件包索引：\nsudo apt update 安装 Docker 引擎：\nsudo apt install docker-ce docker-ce-cli containerd.io 验证 Docker 是否安装成功：\nsudo docker --version 方法二：使用 apt 安装 更新 apt 软件包索引：\nsudo apt update 安装 Docker 引擎：\nsudo apt install docker.io 启动 Docker 服务并设置开机自启：\nsudo systemctl start docker sudo systemctl enable docker 验证 Docker 是否安装成功：\nsudo docker --version 当前用户没有足够的权限来访问 Docker 守护程序的 Unix 套接字， 通常，解决这个问题的一种方法是将当前用户添加到 docker 组中，以便其具有访问 Docker 的权限。 以下是解决此问题的步骤：\n将当前用户添加到 docker 组：\nsudo gpasswd -a $USER docker newgrp docker 这会将当前用户添加到 docker 组中。请注意，这个变更在用户重新登录后才会生效。\n重新登录： 退出当前终端窗口并重新登录，以确保组成员资格生效。\n验证 Docker 权限： 在重新登录后，运行以下命令来验证 Docker 是否现在可以由当前用户访问：\ndocker run hello-world 如果你不再看到 \u0026ldquo;permission denied\u0026rdquo; 错误，说明问题已经解决。\n请注意，为了应用组成员资格的更改，你可能需要重启 Docker 服务。你可以执行以下命令：\nsudo systemctl restart docker Portainer 是一个用于管理 Docker 容器的开源工具，提供用户友好的 Web 界面。以下是在 Docker 中安装 Portainer 的步骤：\n创建一个 Docker 网络（可选）： 这一步是可选的，但它有助于隔离 Portainer 的网络。执行以下命令：\ndocker network create portainer-net 运行 Portainer 容器：\ndocker run -d -p 9000:9000 --name portainer --network portainer-net -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer --restart=always -d: 在后台运行容器。 -p 9000:9000: 将容器的 9000 端口映射到主机的 9000 端口。 --name portainer: 为容器指定一个名称，这里是 \u0026ldquo;portainer\u0026rdquo;。 --network portainer-net: 将容器连接到之前创建的网络（如果有的话）。 -v /var/run/docker.sock:/var/run/docker.sock: 允许 Portainer 访问 Docker 守护程序的 Unix 套接字。 portainer/portainer: 使用 Portainer 的官方 Docker 镜像。 --restart=always: 断电自启动 访问 Portainer Web 界面： 打开浏览器，访问 http://localhost:9000，你将会看到 Portainer 的登录页面。\n设置管理员密码： 在首次访问时，你需要设置一个管理员账户的密码。选择 \u0026ldquo;Manage the Docker instance where Portainer is running\u0026rdquo; 以连接到本地 Docker 守护程序。\n选择 Docker 环境： 在 \u0026ldquo;Endpoint\u0026rdquo; 部分，选择 \u0026ldquo;Docker\u0026rdquo; 以连接到本地 Docker 守护程序。\n完成安装： 设置完成后，点击 \u0026ldquo;Connect\u0026rdquo;，你将进入 Portainer 的仪表板，可以在其中管理 Docker 容器、镜像、网络等。\n安装NVIDIA Container Toolkit (如果你不是GPU服务器或者没有GPU虚拟化需求跳过这一步) 添加 NVIDIA Docker 的软件包存储库并在系统上安装 NVIDIA Container Toolkit。该工具包对将 NVIDIA GPU 与 Docker 容器集成有用。\n让我们分解一下你提供的命令：\n添加软件包存储库：\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list 第一行获取发行版信息。 第二行获取 NVIDIA Docker GPG 密钥并将其添加到系统中。 第三行根据你的发行版获取 NVIDIA Docker 存储库信息，并将其追加到 apt 源中。 更新软件包列表并安装 NVIDIA Container Toolkit：\nsudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y nvidia-container-toolkit sudo apt-get update：刷新软件包列表以包括新添加的 NVIDIA Docker 存储库。 sudo apt-get install -y nvidia-container-toolkit：安装 NVIDIA Container Toolkit。 重新启动 Docker：\nsudo systemctl restart docker 重新启动 Docker 服务以应用通过安装 NVIDIA Container Toolkit 所做的更改。 "},{"section":"Blog","slug":"/blog/post-3/","title":"编译Alluxio源代码","description":"this is meta description","date":"December 13, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo2/DSC_0014_hu2132f61493cb7bff5f9dc7601a1da9ba_2552529_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"226\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo2\\/DSC_0014_hu2132f61493cb7bff5f9dc7601a1da9ba_2552529_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/photo2/DSC_0014_hu2132f61493cb7bff5f9dc7601a1da9ba_2552529_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/photo2\\/DSC_0014_hu2132f61493cb7bff5f9dc7601a1da9ba_2552529_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Distributed Cache, Alluxio","tags":"Distributed Cache, Alluxio, 分布式缓存","content":"0. 编译环境构建 （ssh dcache@xxxxxx）这个服务器已经构建了编译环境，如果如果只需要重编译alluxio直接从1小节开始。\n编译Alluxio源代码 - Alluxio v2.9.3 (stable)\n安装alluxio build https://hub.docker.com/r/alluxio/alluxio/\ndocker pull alluxio/alluxio-maven\ngit alluxio https://github.com/Alluxio/alluxio Alluxio v2.9.3( 当前使用的版本 推荐使用released版本 目前最新分支这个版本用这个编译容器不能通过)\n设置路径\n$ cd alluxio $ export ALLUXIO_HOME=$(pwd) 启动 并 进入容器 # 启动容器 $ docker run -itd --network=host -v ${ALLUXIO_HOME}:/alluxio -v ${HOME}/.m2:/root/.m2 --name alluxio-build alluxio/alluxio-maven bash # 进入容器 $ docker exec -it -w /alluxio alluxio-build bash 由于权限问题，需要把alluxio的项目移到 容器本地的目录并赋予权限 $ mv /alluxio/DIR ～/DIR $ chmod -R 777 ~/DIR 安装并初始化git\ngit clone https 不太行 需要git clone ssh 这样需要在你的github账户添加docker的ssh公钥\n安装npm和node\n版本信息可以参考POM.xml文件\n建议安装nvm进行npm和node版本管理 (如果直接用系统的管理npm很难node版本匹配，node降级npm就崩溃，强烈建议!!!直接上nvm)\nubuntu 安装 NVM\n由于被墙，\n可以先找一个能翻墙的机器，下载.sh的内容，然后手动修改github的DNS (记得还原hosts)\n换源\n墙的问题，需要换源\nnpm 源\n终端输入\n$ npm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) maven 源\n打开 Maven 的配置文件 settings.xml。该文件通常位于 \u0026lt;Maven安装目录\u0026gt;/conf/settings.xml 或 ~/.m2/settings.xml。\n在配置文件中找到 \u0026lt;mirrors\u0026gt; 元素，如果不存在，则可以在 \u0026lt;settings\u0026gt; 元素下创建一个新的 \u0026lt;mirrors\u0026gt; 元素。\n在 \u0026lt;mirrors\u0026gt; 元素中添加一个新的 \u0026lt;mirror\u0026gt; 元素，并指定你希望使用的镜像源。以下是一些常用的 Maven 镜像源：\n\u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyun\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;ustc\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://mirrors.ustc.edu.cn/maven/maven2\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 编译选项问题\n$ mvn clean install -DskipTests # 可以编译 但是很慢 $ mvn -T 2C clean install -DskipTests -Dmaven.javadoc.skip -Dfindbugs.skip -Dcheckstyle.skip -Dlicense.skip # 会卡在npm 不报错，但是没进度 编译24小时没任何反馈 1. 使用编译环境 连接终端\nssh dcache@xxxxx 进入容器\n# 先检查容器是否运行 docker ps -a 如果STATUS为Exited 则需要启动容器\ndocker start CONTAINER ID docker exec -it -w /alluxio alluxio-build bash 否则直接进入容器\ndocker exec -it -w /alluxio alluxio-build bash 到容器内的alluxio路径\n由于文件权限问题，如果编译新的alluxio 需要从外部拷贝到容器内的路径，建议放到~/\n目前～/alluxio 为v2.9.3\n容器与宿主机的接口为/alluxio 即容器目录 /alluxio 映射 宿主机 /home/dcache/zh\n编译\nmvn clean install -DskipTests 编译好之后复制到/alluxio目录即可在宿主机的/zh/ 目录下看到项目\n"},{"section":"Blog","slug":"/blog/post-1/","title":"最优化算法","description":"this is meta description","date":"December 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/DSC_0237_hu6fb553b72bc584c5587e5d3bfd6c33d2_6244350_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"217\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/DSC_0237_hu6fb553b72bc584c5587e5d3bfd6c33d2_6244350_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/DSC_0237_hu6fb553b72bc584c5587e5d3bfd6c33d2_6244350_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/DSC_0237_hu6fb553b72bc584c5587e5d3bfd6c33d2_6244350_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Optimization, EDA","tags":"最优化方法, EDA","content":" 之前做的2篇文章都把问题抽象为一个优化问题，发现自己缺乏对解决优化问题方法（优化算法）进行系统性的学习，这导致每次解决问题时总是用模拟退火或者更简单的启发式方法改改就用。说好听点是发现问题比解决问题更为重要，但其实有种水文章的感觉。虽然这些启发式大多数情况算法也能make sense，但是继续深入学习还是有必要的。\n在此记录学习过程，希望大家指正，但是还没找到给主页添加评论的方法。\n最优化问题范指定量决策问题, 也就是如何对有限的资源进行合理的分配以达到最优目标。\n数学抽象：\n$$ min\\ f(x), \\\\ s.t\\ x \\in \\chi, $$\n"}]